1) Persistent XSS(1)
-Steps to exploit bug:
	(i) Create an image file with name(cannot be done in windows due to filename restriction, but can be done on unix system): a." onerror="alert(1)" 
	(ii) Login to the web application -> Home -> Profile -> Edit my profile
	(iii) Upload the image file on step i) as photo

-Attacker's goal: Inject arbitrary javascript code to anyone who see the our profile's photo.

-If the attack is successful, any user who see our profile's photo would see a message box showing number "1".

#### NEED TO REMEMBER TO PROVIDE THE IMAGE FILE !!!!!   #######
-We don't provide automation tool for this, since we don't know the path in which the image file will be located.
 However, we provide the image file with name: [a." onerror="alert(1)"] for the exploit.


-Vulnerability explanation:
 Currently, everytime the user upload the profile's photo, it will be stored in the server with the following format:
 '[user_id].[photo's extension]'. The photo's extension can be controlled by the user and have no restriction on the server.
 Moreover, we don't sanitize the profile's photo url.



2) Reflected XSS Works in google chrome with XSS Auditor (2)
-Steps to exploit the bug:
	(i) Login to the web application as admin (student@student.com/student)
	(ii) Open the following URL:
	https://[WEB-APP-IP]/admin/edit-info?user_id="</script><scr<script>ipt>alert(1);"

-Attacker's goal: Inject arbitrary javascript code (It can be used to steal admin's cookie, delete other user, etc).

-If the attack is successful, we will see a message box showing number "1".

-The exploit is automatable after the login step as explained above.

-Vulnerability explanation:
 On client side:
 The application will give warning and reflect the user_id input in case the user_id is not exist.
 This warning is not properly sanitized.
 Moreover, the reflection will occur twice (one is shown and one is in HTML comment).
 Since it appear twice, we can trick XSS Auditor by treating the HTML code in between as string (put double quotes).
 And then we need to put the closing tags first before the opening tags.
 On server side:
 The web application server will replace all occurance of <script> to empty string.
 And then it would strip all other tags other than script (using php strip_tag).
 In this case, we can still put script tags by use: <scr<script>ipt>.


3) Reflected XSS Works in google chrome without XSS Auditor (3)
-Steps to exploit the bug:
	(i) Login to the web application as admin (student@student.com/student)
	(ii) Open the following URL:
	https://[WEB-APP-IP]/admin/edit-info?user_id="</script><scr<script>ipt>alert(1);"

-Attacker's goal: Inject arbitrary javascript code (It can be used to steal admin's cookie, delete other user, etc).

-If the attack is successful, we will see a message box showing number "1".

-The exploit is automatable after the login steps as explained above.

-Vulnerability explanation: Similar to previous reflected XSS (2).

4) DOM-based XSS (4)
-Steps to exploit the bug:
	(i) Open the following URL:
	https://[WEB-APP-IP]/users/search?search=<br<b%20onmouseover=alert(1)%20style="display:%20inline-block;width:15000px;%20height:15000px;position:absolute;%20top:0;left:0">
	(ii) Move the mouse pointer to the web-application body (below the header, i.e. near the text User Search).

-Attacker's goal: Inject arbitrary javascript code.

-If the attack is successful, we will see a message box showing number "1".

-The exploit is automatable in a sense that there is a link provided. However, the victim still need to move the mouse pointer inside the web application.

-Vulnerability explanation:
 In the user search page, in case we search [username] that does not exist, it will trigger the javascript to prompt:
 "Cannot find [username]!"
 What the javascript actually does is to take the [username] from the url query parameter with key: search.
 After that, it will try to use regex to strip all tags other than <br>.
 However, there is some bugs with the regex. If there is a not properly closed br open tags ( "<br" ),
 it will other tags inside it. Moreover, the browser will try to parse this other tag inside.
 And it turns out that the other tags we put inside will still allow some event such as 
 onmouseover or onclick (I tested that some event such as onload and onerror didn't work, also other attribute
 such as href or src also didn't work). Hence, we may still exploit this with the above exploit.


 
